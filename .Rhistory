# H <- makeA(ped)  #unstable with large pedigrees, use Amatrix instead
H <- AGHmatrix::Amatrix(ped)
H <- H[rownames(H) %in% parents$ID, colnames(H) %in% parents$ID]
H <- as.matrix(H)
tail(ped)
AGHmatrix::Amatrix(ped)
write.csv(ped,"../ped_check.csv",row.names = F)
str(ped)
ped$DAM <- as.character(ped$DAM)
ped$SIRE <- as.character(ped$SIRE)
AGHmatrix::Amatrix(ped)
source("C:/Users/MHamilton/OneDrive - CGIAR/Desktop/allocatemate/R/peripheral_functions.R")
source("C:/Users/MHamilton/OneDrive - CGIAR/Desktop/allocatemate/R/allocate.mate.ped.R")
parents<- read.csv("../parents.csv")
ped<- read.csv("../ped.csv")
parents$FAM <- as.character(parents$FAM)
source("C:/Users/MHamilton/OneDrive - CGIAR/Desktop/allocatemate/R/peripheral_functions.R")
#Feb 2021
#if("nadiv" %in% installed.packages()[, "Package"] == F) {install.packages("nadiv")}
#library(nadiv)
#library(lpSolveAPI)
#library(AGHmatrix)
#library(dplyr)
#split parents
if(!"N_AS_PARENT" %in% colnames(parents)) {
stop("Column N_AS_PARENT is not present in \'parents\'.")
}
if(!is.integer(parents$N_AS_PARENT)) {
stop("N_AS_PARENT must be a vector of type integer")
}
if(sum(is.na(parents$N_AS_PARENT)) != 0) {
stop("N_AS_PARENT contains missing values")
}
all_candidates <- parents
parents <- parents[parents$N_AS_PARENT > 0,]
#  if(nrow(parents) == nrow(all_candidates)) {
#    all_candidates <-  NULL
#  }
check.parents(parents)
check.ped2(ped)
ped <- reduce.ped(ped = ped, parents = all_candidates)
check.n_fam_crosses(n_fam_crosses)
check.max_F(max_F)
check.method(method)
# if(!is.null(all_candidates)) {
all_candidates <- check.all_candidates(ped, parents, all_candidates)
#  }
#ped <- nadiv::prunePed(ped = ped, phenotyped = parents$ID)
ped[ped$DAM  == 0 & !is.na(ped$DAM), "DAM"]  <- NA
ped[ped$SIRE == 0 & !is.na(ped$SIRE),"SIRE"] <- NA
# ped <- nadiv::prepPed(ped = ped)
ped <- ped.order(pedigree = ped)
ped[is.na(ped$DAM), "DAM"]  <- 0
ped[is.na(ped$SIRE),"SIRE"] <- 0
# H <- makeA(ped)  #unstable with large pedigrees, use Amatrix instead
H <- AGHmatrix::Amatrix(ped)
H <- H[rownames(H) %in% parents$ID, colnames(H) %in% parents$ID]
H <- as.matrix(H)
families <- generate.fams(H = H, ped = ped, parents = parents, max_F = max_F)
if(method == "assortative") {
output <- solve_lp(families = families, parents = parents, n_fam_crosses = n_fam_crosses, max_F = max_F, min_trait = "EBV_dev_squared")
}
if(method == "min_F") {
output <- solve_lp(families = families, parents = parents, n_fam_crosses = n_fam_crosses, max_F = max_F, min_trait = "F")
}
#  if(!is.null(all_candidates)) {
output$mating_list <- get_optimal_all_candidates(optimal_families = output$optimal_families,
all_candidates = all_candidates)
optimal_families = output$optimal_families
optimal_families$CROSS <- 1:nrow(optimal_families)
sires <- get.parents(all_candidates, optimal_families, sex = "M")
optimal_families
all_candidates
get.parents(all_candidates, optimal_families, sex = "M")
ped read.csv("../ped.csv")
ped <- read.csv("../ped.csv")
parents <- read.csv("../parents.csv")
output <- allocate.mate.ped(ped, parents, max_F = 0.02, method = "min_F", n_fam_crosses = 1)
output <- allocate.mate.ped(ped, parents, max_F = 0.02, method = "min_F", n_fam_crosses = 1)
parents$FAM <- as.character(parents$FAM)
output <- allocate.mate.ped(ped, parents, max_F = 0.02, method = "min_F", n_fam_crosses = 1)
max_F = 1
method = "min_F"
n_fam_crosses = 1
#if("nadiv" %in% installed.packages()[, "Package"] == F) {install.packages("nadiv")}
#library(nadiv)
#library(lpSolveAPI)
#library(AGHmatrix)
#library(dplyr)
#split parents
if(!"N_AS_PARENT" %in% colnames(parents)) {
stop("Column N_AS_PARENT is not present in \'parents\'.")
}
if(!is.integer(parents$N_AS_PARENT)) {
stop("N_AS_PARENT must be a vector of type integer")
}
if(sum(is.na(parents$N_AS_PARENT)) != 0) {
stop("N_AS_PARENT contains missing values")
}
all_candidates <- parents
parents <- parents[parents$N_AS_PARENT > 0,]
#  if(nrow(parents) == nrow(all_candidates)) {
#    all_candidates <-  NULL
#  }
check.parents(parents)
source("C:/Users/MHamilton/OneDrive - CGIAR/Desktop/allocatemate/R/peripheral_functions.R")
source("C:/Users/MHamilton/OneDrive - CGIAR/Desktop/allocatemate/R/peripheral_functions.R")
#if("nadiv" %in% installed.packages()[, "Package"] == F) {install.packages("nadiv")}
#library(nadiv)
#library(lpSolveAPI)
#library(AGHmatrix)
#library(dplyr)
#split parents
if(!"N_AS_PARENT" %in% colnames(parents)) {
stop("Column N_AS_PARENT is not present in \'parents\'.")
}
if(!is.integer(parents$N_AS_PARENT)) {
stop("N_AS_PARENT must be a vector of type integer")
}
if(sum(is.na(parents$N_AS_PARENT)) != 0) {
stop("N_AS_PARENT contains missing values")
}
all_candidates <- parents
parents <- parents[parents$N_AS_PARENT > 0,]
#  if(nrow(parents) == nrow(all_candidates)) {
#    all_candidates <-  NULL
#  }
check.parents(parents)
check.ped2(ped)
ped <- reduce.ped(ped = ped, parents = all_candidates)
check.n_fam_crosses(n_fam_crosses)
check.max_F(max_F)
check.method(method)
# if(!is.null(all_candidates)) {
all_candidates <- check.all_candidates(ped, parents, all_candidates)
library(AllocateMate)
#if("nadiv" %in% installed.packages()[, "Package"] == F) {install.packages("nadiv")}
#library(nadiv)
#library(lpSolveAPI)
#library(AGHmatrix)
#library(dplyr)
#split parents
if(!"N_AS_PARENT" %in% colnames(parents)) {
stop("Column N_AS_PARENT is not present in \'parents\'.")
}
if(!is.integer(parents$N_AS_PARENT)) {
stop("N_AS_PARENT must be a vector of type integer")
}
if(sum(is.na(parents$N_AS_PARENT)) != 0) {
stop("N_AS_PARENT contains missing values")
}
all_candidates <- parents
parents <- parents[parents$N_AS_PARENT > 0,]
#  if(nrow(parents) == nrow(all_candidates)) {
#    all_candidates <-  NULL
#  }
check.parents(parents)
check.ped2(ped)
ped <- reduce.ped(ped = ped, parents = all_candidates)
check.n_fam_crosses(n_fam_crosses)
check.max_F(max_F)
check.method(method)
# if(!is.null(all_candidates)) {
all_candidates <- check.all_candidates(ped, parents, all_candidates)
source("C:/Users/MHamilton/OneDrive - CGIAR/Desktop/allocatemate/R/peripheral_functions.R")
#if("nadiv" %in% installed.packages()[, "Package"] == F) {install.packages("nadiv")}
#library(nadiv)
#library(lpSolveAPI)
#library(AGHmatrix)
#library(dplyr)
#split parents
if(!"N_AS_PARENT" %in% colnames(parents)) {
stop("Column N_AS_PARENT is not present in \'parents\'.")
}
if(!is.integer(parents$N_AS_PARENT)) {
stop("N_AS_PARENT must be a vector of type integer")
}
if(sum(is.na(parents$N_AS_PARENT)) != 0) {
stop("N_AS_PARENT contains missing values")
}
all_candidates <- parents
parents <- parents[parents$N_AS_PARENT > 0,]
#  if(nrow(parents) == nrow(all_candidates)) {
#    all_candidates <-  NULL
#  }
check.parents(parents)
check.ped2(ped)
ped <- reduce.ped(ped = ped, parents = all_candidates)
check.n_fam_crosses(n_fam_crosses)
check.max_F(max_F)
check.method(method)
# if(!is.null(all_candidates)) {
all_candidates <- check.all_candidates(ped, parents, all_candidates)
#  }
#ped <- nadiv::prunePed(ped = ped, phenotyped = parents$ID)
ped[ped$DAM  == 0 & !is.na(ped$DAM), "DAM"]  <- NA
ped[ped$SIRE == 0 & !is.na(ped$SIRE),"SIRE"] <- NA
# ped <- nadiv::prepPed(ped = ped)
ped <- ped.order(pedigree = ped)
ped[is.na(ped$DAM), "DAM"]  <- 0
ped[is.na(ped$SIRE),"SIRE"] <- 0
# H <- makeA(ped)  #unstable with large pedigrees, use Amatrix instead
H <- AGHmatrix::Amatrix(ped)
H <- H[rownames(H) %in% parents$ID, colnames(H) %in% parents$ID]
H <- as.matrix(H)
families <- generate.fams(H = H, ped = ped, parents = parents, max_F = max_F)
if(method == "assortative") {
output <- solve_lp(families = families, parents = parents, n_fam_crosses = n_fam_crosses, max_F = max_F, min_trait = "EBV_dev_squared")
}
if(method == "min_F") {
output <- solve_lp(families = families, parents = parents, n_fam_crosses = n_fam_crosses, max_F = max_F, min_trait = "F")
}
output$mating_list <- get_optimal_all_candidates(optimal_families = output$optimal_families,
all_candidates = all_candidates)
output$mating_list <- left_join(output$mating_list,
output$optimal_families[,c("SIRE", "DAM", "F", "EBV")],
by = c("SIRE", "DAM"))
output$A_matrix <- H[rownames(H) %in% c(output$optimal_families$SIRE, output$optimal_families$DAM),
colnames(H) %in% c(output$optimal_families$SIRE, output$optimal_families$DAM)]
output$mating_list
str(parents)
str(all_candidates)
parents <- read.csv("../parents.csv")
parents$FAM <- as.character(parents$FAM)
#mhamilton@cgiar.org
#Feb 2021
#if("nadiv" %in% installed.packages()[, "Package"] == F) {install.packages("nadiv")}
#library(nadiv)
#library(lpSolveAPI)
#library(AGHmatrix)
#library(dplyr)
#split parents
if(!"N_AS_PARENT" %in% colnames(parents)) {
stop("Column N_AS_PARENT is not present in \'parents\'.")
}
if(!is.integer(parents$N_AS_PARENT)) {
stop("N_AS_PARENT must be a vector of type integer")
}
if(sum(is.na(parents$N_AS_PARENT)) != 0) {
stop("N_AS_PARENT contains missing values")
}
all_candidates <- parents
parents <- parents[parents$N_AS_PARENT > 0,]
#  if(nrow(parents) == nrow(all_candidates)) {
#    all_candidates <-  NULL
#  }
check.parents(parents)
check.ped2(ped)
ped <- reduce.ped(ped = ped, parents = all_candidates)
check.n_fam_crosses(n_fam_crosses)
check.max_F(max_F)
check.method(method)
# if(!is.null(all_candidates)) {
all_candidates <- check.all_candidates(ped, parents, all_candidates)
ped <- read.csv("../ped.csv")
#mhamilton@cgiar.org
#Feb 2021
#if("nadiv" %in% installed.packages()[, "Package"] == F) {install.packages("nadiv")}
#library(nadiv)
#library(lpSolveAPI)
#library(AGHmatrix)
#library(dplyr)
#split parents
if(!"N_AS_PARENT" %in% colnames(parents)) {
stop("Column N_AS_PARENT is not present in \'parents\'.")
}
if(!is.integer(parents$N_AS_PARENT)) {
stop("N_AS_PARENT must be a vector of type integer")
}
if(sum(is.na(parents$N_AS_PARENT)) != 0) {
stop("N_AS_PARENT contains missing values")
}
all_candidates <- parents
parents <- parents[parents$N_AS_PARENT > 0,]
#  if(nrow(parents) == nrow(all_candidates)) {
#    all_candidates <-  NULL
#  }
check.parents(parents)
check.ped2(ped)
ped <- reduce.ped(ped = ped, parents = all_candidates)
check.n_fam_crosses(n_fam_crosses)
check.max_F(max_F)
check.method(method)
# if(!is.null(all_candidates)) {
all_candidates <- check.all_candidates(ped, parents, all_candidates)
#  }
#ped <- nadiv::prunePed(ped = ped, phenotyped = parents$ID)
ped[ped$DAM  == 0 & !is.na(ped$DAM), "DAM"]  <- NA
ped[ped$SIRE == 0 & !is.na(ped$SIRE),"SIRE"] <- NA
# ped <- nadiv::prepPed(ped = ped)
ped <- ped.order(pedigree = ped)
ped[is.na(ped$DAM), "DAM"]  <- 0
ped[is.na(ped$SIRE),"SIRE"] <- 0
# H <- makeA(ped)  #unstable with large pedigrees, use Amatrix instead
H <- AGHmatrix::Amatrix(ped)
H <- H[rownames(H) %in% parents$ID, colnames(H) %in% parents$ID]
H <- as.matrix(H)
families <- generate.fams(H = H, ped = ped, parents = parents, max_F = max_F)
if(method == "assortative") {
output <- solve_lp(families = families, parents = parents, n_fam_crosses = n_fam_crosses, max_F = max_F, min_trait = "EBV_dev_squared")
}
if(method == "min_F") {
output <- solve_lp(families = families, parents = parents, n_fam_crosses = n_fam_crosses, max_F = max_F, min_trait = "F")
}
#  if(!is.null(all_candidates)) {
output$mating_list <- get_optimal_all_candidates(optimal_families = output$optimal_families,
all_candidates = all_candidates)
output$mating_list <- left_join(output$mating_list,
output$optimal_families[,c("SIRE", "DAM", "F", "EBV")],
by = c("SIRE", "DAM"))
#  }
output$A_matrix <- H[rownames(H) %in% c(output$optimal_families$SIRE, output$optimal_families$DAM),
colnames(H) %in% c(output$optimal_families$SIRE, output$optimal_families$DAM)]
output$A_matrix
output$mating_list
ped <- read.csv("../ped.csv")
parents <- read.csv("../parents.csv")
parents$FAM <- as.character(parents$FAM)
#mhamilton@cgiar.org
#Feb 2021
#if("nadiv" %in% installed.packages()[, "Package"] == F) {install.packages("nadiv")}
#library(nadiv)
#library(lpSolveAPI)
#library(AGHmatrix)
#library(dplyr)
#split parents
if(!"N_AS_PARENT" %in% colnames(parents)) {
stop("Column N_AS_PARENT is not present in \'parents\'.")
}
if(!is.integer(parents$N_AS_PARENT)) {
stop("N_AS_PARENT must be a vector of type integer")
}
if(sum(is.na(parents$N_AS_PARENT)) != 0) {
stop("N_AS_PARENT contains missing values")
}
all_candidates <- parents
parents <- parents[parents$N_AS_PARENT > 0,]
#  if(nrow(parents) == nrow(all_candidates)) {
#    all_candidates <-  NULL
#  }
check.parents(parents)
check.ped2(ped)
ped <- reduce.ped(ped = ped, parents = all_candidates)
check.n_fam_crosses(n_fam_crosses)
check.max_F(max_F)
check.method(method)
# if(!is.null(all_candidates)) {
all_candidates <- check.all_candidates(ped, parents, all_candidates)
#  }
#ped <- nadiv::prunePed(ped = ped, phenotyped = parents$ID)
ped[ped$DAM  == 0 & !is.na(ped$DAM), "DAM"]  <- NA
ped[ped$SIRE == 0 & !is.na(ped$SIRE),"SIRE"] <- NA
# ped <- nadiv::prepPed(ped = ped)
ped <- ped.order(pedigree = ped)
ped[is.na(ped$DAM), "DAM"]  <- 0
ped[is.na(ped$SIRE),"SIRE"] <- 0
# H <- makeA(ped)  #unstable with large pedigrees, use Amatrix instead
H <- AGHmatrix::Amatrix(ped)
H <- H[rownames(H) %in% parents$ID, colnames(H) %in% parents$ID]
H <- as.matrix(H)
families <- generate.fams(H = H, ped = ped, parents = parents, max_F = max_F)
if(method == "assortative") {
output <- solve_lp(families = families, parents = parents, n_fam_crosses = n_fam_crosses, max_F = max_F, min_trait = "EBV_dev_squared")
}
if(method == "min_F") {
output <- solve_lp(families = families, parents = parents, n_fam_crosses = n_fam_crosses, max_F = max_F, min_trait = "F")
}
#  if(!is.null(all_candidates)) {
output$mating_list <- get_optimal_all_candidates(optimal_families = output$optimal_families,
all_candidates = all_candidates)
optimal_families = output$optimal_families
optimal_families$CROSS <- 1:nrow(optimal_families)
sires <- get.parents(all_candidates, optimal_families, sex = "M")
sex = "M"
indivs <- all_candidates[all_candidates$SEX == sex, c("ID", "EBV", "FAM")]
colnames(indivs) <- c("INDIV", "INDIV_EBV", "INDIV_FAM")
indivs <- indivs[order(runif(nrow(indivs))),]
if(sex == "M") {
optimal_indivs <- optimal_families[,c("SIRE", "CROSS")]
}
if(sex == "F") {
optimal_indivs <- optimal_families[,c("DAM", "CROSS")]
}
colnames(optimal_indivs) <- c("INDIV", "CROSS")
indivs <- indivs %>%
group_by(INDIV_FAM) %>% # Group the data by 'INDIV_FAM' to rank 'INDIV_EBV' within these groups
# Rank 'INDIV_EBV' values within each group, in descending order.
# 'dense_rank()' assigns sequential ranks, even for tied values (no gaps in ranks).
# The '-' before 'INDIV_EBV' ranks the values in descending order (higher INDIV_EBV gets a lower rank)
mutate(INDIV_RANK = dense_rank(-INDIV_EBV)) %>%
# Ungroup the data so it's no longer grouped by 'INDIV_FAM'
# This is important for further analysis to avoid accidental grouping in later operations
ungroup()
indivs <- as.data.frame(indivs)
optimal_indivs <- left_join(optimal_indivs, indivs, by = "INDIV") #"INDIV", "INDIV_EBV", "INDIV_FAM", "INDIV_RANK", "CROSS"
if(mean(optimal_indivs$INDIV_RANK) < mean(indivs$INDIV_RANK)) { #Highest EBV ranked 1
indivs[order(indivs$INDIV_EBV , decreasing = F),]
optimal_indivs[order(optimal_indivs$INDIV_EBV, decreasing = F),]
} else {                                                    #Lowest EBV ranked 1
#re-rank in opposite order
indivs <- indivs %>%
group_by(INDIV_FAM) %>%
mutate(INDIV_RANK = dense_rank(INDIV_EBV)) %>%
ungroup()
indivs <- as.data.frame(indivs)
#regenerate optimal_indivs with modified rankings
optimal_indivs <- left_join(optimal_indivs, indivs) #"INDIV", "INDIV_EBV", "INDIV_FAM", "INDIV_RANK", "CROSS"
indivs[order(indivs$INDIV_EBV, decreasing = T),]
optimal_indivs[order(optimal_indivs$INDIV_EBV, decreasing = T),]
}
(mean(optimal_indivs$INDIV_RANK) < mean(indivs$INDIV_RANK))
indivs[order(indivs$INDIV_EBV , decreasing = F),]
optimal_indivs[order(optimal_indivs$INDIV_EBV, decreasing = F),]
source("C:/Users/MHamilton/OneDrive - CGIAR/Desktop/allocatemate/R/peripheral_functions.R")
if(mean(optimal_indivs$INDIV_RANK) < mean(indivs$INDIV_RANK)) { #Highest EBV ranked 1
indivs <- indivs[order(indivs$INDIV_EBV , decreasing = F),]
optimal_indivs <- optimal_indivs[order(optimal_indivs$INDIV_EBV, decreasing = F),]
} else {                                                    #Lowest EBV ranked 1
#re-rank in opposite order
indivs <- indivs %>%
group_by(INDIV_FAM) %>%
mutate(INDIV_RANK = dense_rank(INDIV_EBV)) %>%
ungroup()
indivs <- as.data.frame(indivs)
#regenerate optimal_indivs with modified rankings
optimal_indivs <- left_join(optimal_indivs, indivs) #"INDIV", "INDIV_EBV", "INDIV_FAM", "INDIV_RANK", "CROSS"
indivs <- indivs[order(indivs$INDIV_EBV, decreasing = T),]
optimal_indivs <- optimal_indivs[order(optimal_indivs$INDIV_EBV, decreasing = T),]
}
all_indivs <- NULL
for(fam in unique(optimal_indivs$INDIV_FAM)) {
tmp_optimal_indivs <- optimal_indivs[optimal_indivs$INDIV_FAM == fam,]
tmp_optimal_indivs$INDIV_GROUP <- 1:nrow(tmp_optimal_indivs)
tmp_optimal_indivs$CATEGORY <- "Selected"
tmp_indivs <- indivs[indivs$INDIV_FAM == fam,]
tmp_indivs <- tmp_indivs[!tmp_indivs$INDIV %in% tmp_optimal_indivs$INDIV,]
if(nrow(tmp_indivs)> 0) {
tmp_indivs$CATEGORY <- "Backup"
tmp_indivs$INDIV_GROUP <- seq(1, nrow(tmp_indivs), by = nrow(tmp_optimal_indivs))
tmp_indivs <- left_join(tmp_indivs, tmp_optimal_indivs[,c("INDIV_FAM", "CROSS", "INDIV_GROUP")], by = c("INDIV_FAM", "INDIV_GROUP"))
tmp_indivs <- rbind(tmp_optimal_indivs[,colnames(tmp_indivs)], tmp_indivs)
tmp_indivs <- tmp_indivs[order(tmp_indivs$INDIV_GROUP),c("INDIV", "INDIV_EBV", "INDIV_FAM", "INDIV_RANK", "CROSS", "CATEGORY")]
all_indivs <- rbind(all_indivs, tmp_indivs)
rm(tmp_indivs)
} else {
all_indivs <- rbind(all_indivs, tmp_optimal_indivs)
}
rm(tmp_optimal_indivs)
}
fam
unique(optimal_indivs$INDIV_FAM)
all_indivs
tmp_indivs
(nrow(tmp_indivs)> 0)
tmp_optimal_indivs
source("C:/Users/MHamilton/OneDrive - CGIAR/Desktop/allocatemate/R/peripheral_functions.R")
for(fam in unique(optimal_indivs$INDIV_FAM)) {
tmp_optimal_indivs <- optimal_indivs[optimal_indivs$INDIV_FAM == fam,]
tmp_optimal_indivs$INDIV_GROUP <- 1:nrow(tmp_optimal_indivs)
tmp_optimal_indivs$CATEGORY <- "Selected"
tmp_indivs <- indivs[indivs$INDIV_FAM == fam,]
tmp_indivs <- tmp_indivs[!tmp_indivs$INDIV %in% tmp_optimal_indivs$INDIV,]
if(nrow(tmp_indivs)> 0) {
tmp_indivs$CATEGORY <- "Backup"
tmp_indivs$INDIV_GROUP <- seq(1, nrow(tmp_indivs), by = nrow(tmp_optimal_indivs))
tmp_indivs <- left_join(tmp_indivs, tmp_optimal_indivs[,c("INDIV_FAM", "CROSS", "INDIV_GROUP")], by = c("INDIV_FAM", "INDIV_GROUP"))
tmp_indivs <- rbind(tmp_optimal_indivs[,colnames(tmp_indivs)], tmp_indivs)
tmp_indivs <- tmp_indivs[order(tmp_indivs$INDIV_GROUP),c("INDIV", "INDIV_EBV", "INDIV_FAM", "INDIV_RANK", "CROSS", "CATEGORY")]
all_indivs <- rbind(all_indivs, tmp_indivs)
rm(tmp_indivs)
} else {
tmp_optimal_indivs <- tmp_optimal_indivs[,c("INDIV", "INDIV_EBV", "INDIV_FAM", "INDIV_RANK", "CROSS", "CATEGORY")]
all_indivs <- rbind(all_indivs, tmp_optimal_indivs)
}
rm(tmp_optimal_indivs)
}
all_indivs <- NULL
for(fam in unique(optimal_indivs$INDIV_FAM)) {
tmp_optimal_indivs <- optimal_indivs[optimal_indivs$INDIV_FAM == fam,]
tmp_optimal_indivs$INDIV_GROUP <- 1:nrow(tmp_optimal_indivs)
tmp_optimal_indivs$CATEGORY <- "Selected"
tmp_indivs <- indivs[indivs$INDIV_FAM == fam,]
tmp_indivs <- tmp_indivs[!tmp_indivs$INDIV %in% tmp_optimal_indivs$INDIV,]
if(nrow(tmp_indivs)> 0) {
tmp_indivs$CATEGORY <- "Backup"
tmp_indivs$INDIV_GROUP <- seq(1, nrow(tmp_indivs), by = nrow(tmp_optimal_indivs))
tmp_indivs <- left_join(tmp_indivs, tmp_optimal_indivs[,c("INDIV_FAM", "CROSS", "INDIV_GROUP")], by = c("INDIV_FAM", "INDIV_GROUP"))
tmp_indivs <- rbind(tmp_optimal_indivs[,colnames(tmp_indivs)], tmp_indivs)
tmp_indivs <- tmp_indivs[order(tmp_indivs$INDIV_GROUP),c("INDIV", "INDIV_EBV", "INDIV_FAM", "INDIV_RANK", "CROSS", "CATEGORY")]
all_indivs <- rbind(all_indivs, tmp_indivs)
rm(tmp_indivs)
} else {
tmp_optimal_indivs <- tmp_optimal_indivs[,c("INDIV", "INDIV_EBV", "INDIV_FAM", "INDIV_RANK", "CROSS", "CATEGORY")]
all_indivs <- rbind(all_indivs, tmp_optimal_indivs)
}
rm(tmp_optimal_indivs)
}
if(sex == "M") {
colnames(all_indivs) <- c("SIRE", "CROSS", "SIRE_EBV", "SIRE_FAM", "SIRE_RANK", "CROSS", "SIRE_CATEGORY")
}
all_indivs
if(sex == "M") {
colnames(all_indivs) <- c("SIRE", "SIRE_EBV", "SIRE_FAM", "SIRE_RANK", "CROSS", "SIRE_CATEGORY")
}
all_indivs
source("C:/Users/MHamilton/OneDrive - CGIAR/Desktop/allocatemate/R/peripheral_functions.R")
output$mating_list <- get_optimal_all_candidates(optimal_families = output$optimal_families,
all_candidates = all_candidates)
output$mating_list <- left_join(output$mating_list,
output$optimal_families[,c("SIRE", "DAM", "F", "EBV")],
by = c("SIRE", "DAM"))
output$mating_list
