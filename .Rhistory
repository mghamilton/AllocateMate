ped <- AllocateMate::ped
parents <- AllocateMate::parents
output <- allocate.mate.ped(ped, parents, max_F = 0.02, method = "min_F", n_fam_crosses = 1)
max_F = 1
method = "min_F"
n_fam_crosses = 1
#if("nadiv" %in% installed.packages()[, "Package"] == F) {install.packages("nadiv")}
#library(nadiv)
#library(lpSolveAPI)
#library(AGHmatrix)
#library(dplyr)
#split parents
if(!"N_AS_PARENT" %in% colnames(parents)) {
stop("Column N_AS_PARENT is not present in \'parents\'.")
}
if(!is.integer(parents$N_AS_PARENT)) {
stop("N_AS_PARENT must be a vector of type integer")
}
if(sum(is.na(parents$N_AS_PARENT)) != 0) {
stop("N_AS_PARENT contains missing values")
}
all_candidates <- parents
parents <- parents[parents$N_AS_PARENT > 0,]
if(nrow(parents) == nrow(all_candidates)) {
all_candidates <-  NULL
}
check.parents(parents)
source("C:/Users/MHamilton/OneDrive - CGIAR/Desktop/allocatemate/R/peripheral_functions.R")
#if("nadiv" %in% installed.packages()[, "Package"] == F) {install.packages("nadiv")}
#library(nadiv)
#library(lpSolveAPI)
#library(AGHmatrix)
#library(dplyr)
#split parents
if(!"N_AS_PARENT" %in% colnames(parents)) {
stop("Column N_AS_PARENT is not present in \'parents\'.")
}
if(!is.integer(parents$N_AS_PARENT)) {
stop("N_AS_PARENT must be a vector of type integer")
}
if(sum(is.na(parents$N_AS_PARENT)) != 0) {
stop("N_AS_PARENT contains missing values")
}
all_candidates <- parents
parents <- parents[parents$N_AS_PARENT > 0,]
if(nrow(parents) == nrow(all_candidates)) {
all_candidates <-  NULL
}
check.parents(parents)
check.ped2(ped)
ped <- reduce.ped(ped = ped, parents = parents)
check.n_fam_crosses(n_fam_crosses)
check.max_F(max_F)
check.method(method)
if(!is.null(all_candidates)) {
check.all_candidates(ped, parents, all_candidates)
}
#ped <- nadiv::prunePed(ped = ped, phenotyped = parents$ID)
ped[ped$DAM  == 0 & !is.na(ped$DAM), "DAM"]  <- NA
ped[ped$SIRE == 0 & !is.na(ped$SIRE),"SIRE"] <- NA
# ped <- nadiv::prepPed(ped = ped)
ped <- ped.order(pedigree = ped)
ped[is.na(ped$DAM), "DAM"]  <- 0
ped[is.na(ped$SIRE),"SIRE"] <- 0
# H <- makeA(ped)  #unstable with large pedigrees, use Amatrix instead
H <- AGHmatrix::Amatrix(ped)
H <- H[rownames(H) %in% parents$ID, colnames(H) %in% parents$ID]
H <- as.matrix(H)
families <- generate.fams(H = H, ped = ped, parents = parents, max_F = max_F)
if(method == "assortative") {
output <- solve_lp(families = families, parents = parents, n_fam_crosses = n_fam_crosses, max_F = max_F, min_trait = "EBV_dev_squared")
}
if(method == "min_F") {
output <- solve_lp(families = families, parents = parents, n_fam_crosses = n_fam_crosses, max_F = max_F, min_trait = "F")
}
(!is.null(all_candidates))
get_optimal_all_candidates(optimal_families = output$optimal_families,
all_candidates = all_candidates)
optimal_families = output$optimal_families
optimal_families$CROSS <- 1:nrow(optimal_families)
sires <- get.parents(all_candidates, optimal_families, sex = "M")
optimal_families$CROSS <- 1:nrow(optimal_families)
sires <- get.parents(all_candidates, optimal_families, sex = "M")
source("C:/Users/MHamilton/OneDrive - CGIAR/Desktop/allocatemate/R/allocate.mate.ped.tilapia.R")
ped <- AllocateMate::ped
parents <- AllocateMate::parents
output <- allocate.mate.ped(ped, parents, max_F = 0.02, method = "min_F", n_fam_crosses = 1)
all_candidates$SEX
all_candidates
#if("nadiv" %in% installed.packages()[, "Package"] == F) {install.packages("nadiv")}
#library(nadiv)
#library(lpSolveAPI)
#library(AGHmatrix)
#library(dplyr)
#split parents
if(!"N_AS_PARENT" %in% colnames(parents)) {
stop("Column N_AS_PARENT is not present in \'parents\'.")
}
if(!is.integer(parents$N_AS_PARENT)) {
stop("N_AS_PARENT must be a vector of type integer")
}
if(sum(is.na(parents$N_AS_PARENT)) != 0) {
stop("N_AS_PARENT contains missing values")
}
all_candidates <- parents
parents <- parents[parents$N_AS_PARENT > 0,]
#  if(nrow(parents) == nrow(all_candidates)) {
#    all_candidates <-  NULL
#  }
all_candidates
check.parents(parents)
check.ped2(ped)
ped <- reduce.ped(ped = ped, parents = parents)
check.n_fam_crosses(n_fam_crosses)
check.max_F(max_F)
check.method(method)
if(!is.null(all_candidates)) {
check.all_candidates(ped, parents, all_candidates)
}
#ped <- nadiv::prunePed(ped = ped, phenotyped = parents$ID)
ped[ped$DAM  == 0 & !is.na(ped$DAM), "DAM"]  <- NA
ped[ped$SIRE == 0 & !is.na(ped$SIRE),"SIRE"] <- NA
# ped <- nadiv::prepPed(ped = ped)
ped <- ped.order(pedigree = ped)
ped[is.na(ped$DAM), "DAM"]  <- 0
ped[is.na(ped$SIRE),"SIRE"] <- 0
# H <- makeA(ped)  #unstable with large pedigrees, use Amatrix instead
H <- AGHmatrix::Amatrix(ped)
H <- H[rownames(H) %in% parents$ID, colnames(H) %in% parents$ID]
H <- as.matrix(H)
families <- generate.fams(H = H, ped = ped, parents = parents, max_F = max_F)
if(method == "assortative") {
output <- solve_lp(families = families, parents = parents, n_fam_crosses = n_fam_crosses, max_F = max_F, min_trait = "EBV_dev_squared")
}
if(method == "min_F") {
output <- solve_lp(families = families, parents = parents, n_fam_crosses = n_fam_crosses, max_F = max_F, min_trait = "F")
}
check.parents(parents)
check.ped2(ped)
ped <- reduce.ped(ped = ped, parents = parents)
check.n_fam_crosses(n_fam_crosses)
check.max_F(max_F)
check.method(method)
if(!is.null(all_candidates)) {
check.all_candidates(ped, parents, all_candidates)
}
#ped <- nadiv::prunePed(ped = ped, phenotyped = parents$ID)
ped[ped$DAM  == 0 & !is.na(ped$DAM), "DAM"]  <- NA
ped[ped$SIRE == 0 & !is.na(ped$SIRE),"SIRE"] <- NA
# ped <- nadiv::prepPed(ped = ped)
ped <- ped.order(pedigree = ped)
ped[is.na(ped$DAM), "DAM"]  <- 0
ped[is.na(ped$SIRE),"SIRE"] <- 0
# H <- makeA(ped)  #unstable with large pedigrees, use Amatrix instead
H <- AGHmatrix::Amatrix(ped)
H <- H[rownames(H) %in% parents$ID, colnames(H) %in% parents$ID]
H <- as.matrix(H)
families <- generate.fams(H = H, ped = ped, parents = parents, max_F = max_F)
if(method == "assortative") {
output <- solve_lp(families = families, parents = parents, n_fam_crosses = n_fam_crosses, max_F = max_F, min_trait = "EBV_dev_squared")
}
if(method == "min_F") {
output <- solve_lp(families = families, parents = parents, n_fam_crosses = n_fam_crosses, max_F = max_F, min_trait = "F")
}
all_candidates
get_optimal_all_candidates(optimal_families = output$optimal_families,
all_candidates = all_candidates)
source("C:/Users/MHamilton/OneDrive - CGIAR/Desktop/allocatemate/R/peripheral_functions.R")
all_candidates
optimal_families = output$optimal_families
optimal_families$CROSS <- 1:nrow(optimal_families)
sires <- get.parents(all_candidates, optimal_families, sex = "M")
optimal_families
all_candidates
sex = "M"
all_candidates
optimal_families
all_candidates
all_candidates[all_candidates$SEX == sex, c("ID", "EBV", "FAM")]
ped <- AllocateMate::ped
parents <- AllocateMate::parents
#if("nadiv" %in% installed.packages()[, "Package"] == F) {install.packages("nadiv")}
#library(nadiv)
#library(lpSolveAPI)
#library(AGHmatrix)
#library(dplyr)
#split parents
if(!"N_AS_PARENT" %in% colnames(parents)) {
stop("Column N_AS_PARENT is not present in \'parents\'.")
}
if(!is.integer(parents$N_AS_PARENT)) {
stop("N_AS_PARENT must be a vector of type integer")
}
if(sum(is.na(parents$N_AS_PARENT)) != 0) {
stop("N_AS_PARENT contains missing values")
}
all_candidates <- parents
parents <- parents[parents$N_AS_PARENT > 0,]
#  if(nrow(parents) == nrow(all_candidates)) {
#    all_candidates <-  NULL
#  }
check.parents(parents)
check.ped2(ped)
ped <- reduce.ped(ped = ped, parents = parents)
check.n_fam_crosses(n_fam_crosses)
check.max_F(max_F)
check.method(method)
# if(!is.null(all_candidates)) {
check.all_candidates(ped, parents, all_candidates)
colnames
(all_candidates)
all_candidates
parents
ped
if(sum(colnames(all_candidates) %in% c("ID", "SEX", "EBV")) != 3) {
stop("Column names of parents must include: ID, SEX and EBV (FAM is optional)")
}
all_candidates <- all_candidates[,colnames(all_candidates) %in% c("ID", "SEX", "EBV", "FAM")]
if(!is.character(all_candidates$ID)) {
stop("ID in \'parents\' must be of type character")
}
if(sum(!all_candidates$SEX %in% c("M","F")) > 0) {
stop("SEX in \'parents\' must be of type character comprised of M or F, for male and female respectively")
}
if(!is.numeric(all_candidates$EBV)) {
stop("EBV in \'parents\' must be of type numeric")
}
if(sum(is.na(all_candidates$ID)) > 0) {
stop("ID field of \'parents\' must not contain missing values")
}
if(sum(is.na(all_candidates$SEX)) > 0) {
stop("SEX field of \'parents\' must not contain missing values")
}
#all_candidates vs ped
if (sum(!all_candidates$ID %in% ped$ID) != 0) {
stop("Not all IDs in \'parents\' are present in \'ped\'")
}
id_check <- all_candidates[!all_candidates$ID %in% ped$ID, "ID"]
if (length(id_check) > 0) {
stop(paste0("Not all IDs in \'parents\' are present in \'ped\'. Check IDs: ",
paste(id_check, collapse = " ")))
}
rm(id_check)
all_candidates <- left_join(all_candidates, ped, by = "ID")
("FAM" %in% colnames(all_candidates))
fams <- unique(all_candidates[,c("SIRE", "DAM")])
fams
fams$FAM <- as.character(paste0(fams$SIRE, "_", fams$DAM)) #as.character(1:nrow(fams))
fams
all_candidates <- left_join(all_candidates, fams, by = c("SIRE", "DAM"))
all_candidates <- left_join(all_candidates, fams, by = c("SIRE", "DAM"))
all_candidates
source("C:/Users/MHamilton/OneDrive - CGIAR/Desktop/allocatemate/R/peripheral_functions.R")
source("C:/Users/MHamilton/OneDrive - CGIAR/Desktop/allocatemate/R/allocate.mate.ped.tilapia.R")
output <- allocate.mate.ped(ped, parents, max_F = 0.02, method = "min_F", n_fam_crosses = 1)
output$optimal_families_all_cand
head( output$optimal_families)
source("C:/Users/MHamilton/OneDrive - CGIAR/Desktop/allocatemate/R/allocate.mate.ped.tilapia.R")
output <- allocate.mate.ped(ped, parents, max_F = 0.02, method = "min_F", n_fam_crosses = 1)
output$optimal_families_all_cand
source("C:/Users/MHamilton/OneDrive - CGIAR/Desktop/allocatemate/R/peripheral_functions.R")
output$optimal_families
load("C:/Users/MHamilton/OneDrive - CGIAR/Desktop/allocatemate/data/parents.rda")
parents
getwd()
write.csv(parents, "../parents.csv", row.names = F)
parents <- left_join(parents,ped)
write.csv(parents, "../parents.csv", row.names = F)
ped <- AllocateMate::ped
write.csv(ped, "../ped.csv", row.names = F)
parents <- read.csv("../parents.csv")
ped <- read.csv("../ped.csv")
rm(list=ls())
parents <- read.csv("../parents.csv")
ped <- read.csv("../ped.csv")
output <- allocate.mate.ped(ped, parents, max_F = 0.02, method = "min_F", n_fam_crosses = 1)
source("C:/Users/MHamilton/OneDrive - CGIAR/Desktop/allocatemate/R/peripheral_functions.R")
output <- allocate.mate.ped(ped, parents, max_F = 0.02, method = "min_F", n_fam_crosses = 1)
(sum(parents$N_AS_PARENT < 0) > 0)
source("C:/Users/MHamilton/OneDrive - CGIAR/Desktop/allocatemate/R/peripheral_functions.R")
source("C:/Users/MHamilton/OneDrive - CGIAR/Desktop/allocatemate/R/peripheral_functions.R")
source("C:/Users/MHamilton/OneDrive - CGIAR/Desktop/allocatemate/R/peripheral_functions.R")
output <- allocate.mate.ped(ped, parents, max_F = 0.02, method = "min_F", n_fam_crosses = 1)
check.parents
#split parents
if(!"N_AS_PARENT" %in% colnames(parents)) {
stop("Column N_AS_PARENT is not present in \'parents\'.")
}
if(!is.integer(parents$N_AS_PARENT)) {
stop("N_AS_PARENT must be a vector of type integer")
}
if(sum(is.na(parents$N_AS_PARENT)) != 0) {
stop("N_AS_PARENT contains missing values")
}
all_candidates <- parents
parents <- parents[parents$N_AS_PARENT > 0,]
#  if(nrow(parents) == nrow(all_candidates)) {
#    all_candidates <-  NULL
#  }
check.parents(parents)
check.ped2(ped)
ped <- reduce.ped(ped = ped, parents = parents)
check.n_fam_crosses(n_fam_crosses)
source("C:/Users/MHamilton/OneDrive - CGIAR/Desktop/allocatemate/R/allocate.mate.ped.R")
output <- allocate.mate.ped(ped, parents, max_F = 0.02, method = "min_F", n_fam_crosses = 1)
parents$FAM <- as.character(parents$FAM)
output <- allocate.mate.ped(ped, parents, max_F = 0.02, method = "min_F", n_fam_crosses = 1)
max_F = 1
method = "min_F"
n_fam_crosses = 1
#split parents
if(!"N_AS_PARENT" %in% colnames(parents)) {
stop("Column N_AS_PARENT is not present in \'parents\'.")
}
if(!is.integer(parents$N_AS_PARENT)) {
stop("N_AS_PARENT must be a vector of type integer")
}
if(sum(is.na(parents$N_AS_PARENT)) != 0) {
stop("N_AS_PARENT contains missing values")
}
all_candidates <- parents
parents <- parents[parents$N_AS_PARENT > 0,]
parents
check.parents(parents)
check.ped2(ped)
ped <- reduce.ped(ped = ped, parents = parents)
check.n_fam_crosses(n_fam_crosses)
check.max_F(max_F)
check.method(method)
# if(!is.null(all_candidates)) {
all_candidates <- check.all_candidates(ped, parents, all_candidates)
#  }
#ped <- nadiv::prunePed(ped = ped, phenotyped = parents$ID)
ped[ped$DAM  == 0 & !is.na(ped$DAM), "DAM"]  <- NA
ped[ped$SIRE == 0 & !is.na(ped$SIRE),"SIRE"] <- NA
# ped <- nadiv::prepPed(ped = ped)
ped <- ped.order(pedigree = ped)
ped[is.na(ped$DAM), "DAM"]  <- 0
ped[is.na(ped$SIRE),"SIRE"] <- 0
# H <- makeA(ped)  #unstable with large pedigrees, use Amatrix instead
H <- AGHmatrix::Amatrix(ped)
H <- H[rownames(H) %in% parents$ID, colnames(H) %in% parents$ID]
H <- as.matrix(H)
check.parents(parents)
check.ped2(ped)
ped <- reduce.ped(ped = ped, parents = parents)
check.n_fam_crosses(n_fam_crosses)
check.max_F(max_F)
check.method(method)
# if(!is.null(all_candidates)) {
all_candidates <- check.all_candidates(ped, parents, all_candidates)
#  }
#ped <- nadiv::prunePed(ped = ped, phenotyped = parents$ID)
ped[ped$DAM  == 0 & !is.na(ped$DAM), "DAM"]  <- NA
ped[ped$SIRE == 0 & !is.na(ped$SIRE),"SIRE"] <- NA
# ped <- nadiv::prepPed(ped = ped)
ped <- ped.order(pedigree = ped)
ped[is.na(ped$DAM), "DAM"]  <- 0
ped[is.na(ped$SIRE),"SIRE"] <- 0
# H <- makeA(ped)  #unstable with large pedigrees, use Amatrix instead
H <- AGHmatrix::Amatrix(ped)
H <- H[rownames(H) %in% parents$ID, colnames(H) %in% parents$ID]
H <- as.matrix(H)
ped
read.csv("../ped.csv")
ped<- read.csv("../ped.csv")
parents<- read.csv("../parents.csv")
check.parents(parents)
check.ped2(ped)
ped <- reduce.ped(ped = ped, parents = parents)
check.n_fam_crosses(n_fam_crosses)
check.max_F(max_F)
check.method(method)
# if(!is.null(all_candidates)) {
all_candidates <- check.all_candidates(ped, parents, all_candidates)
parents
all_candidates
all_candidates
parents<- read.csv("../parents.csv")
#split parents
if(!"N_AS_PARENT" %in% colnames(parents)) {
stop("Column N_AS_PARENT is not present in \'parents\'.")
}
if(!is.integer(parents$N_AS_PARENT)) {
stop("N_AS_PARENT must be a vector of type integer")
}
if(sum(is.na(parents$N_AS_PARENT)) != 0) {
stop("N_AS_PARENT contains missing values")
}
all_candidates <- parents
#split parents
if(!"N_AS_PARENT" %in% colnames(parents)) {
stop("Column N_AS_PARENT is not present in \'parents\'.")
}
if(!is.integer(parents$N_AS_PARENT)) {
stop("N_AS_PARENT must be a vector of type integer")
}
if(sum(is.na(parents$N_AS_PARENT)) != 0) {
stop("N_AS_PARENT contains missing values")
}
all_candidates <- parents
parents <- parents[parents$N_AS_PARENT > 0,]
View(parents)
View(all_candidates)
check.n_fam_crosses(n_fam_crosses)
check.max_F(max_F)
check.method(method)
# if(!is.null(all_candidates)) {
all_candidates <- check.all_candidates(ped, parents, all_candidates)
parents$FAM <- as.character(parents$FAM)
ped <- reduce.ped(ped = ped, parents = all_candidates)
check.n_fam_crosses(n_fam_crosses)
check.max_F(max_F)
check.method(method)
# if(!is.null(all_candidates)) {
all_candidates <- check.all_candidates(ped, parents, all_candidates)
parents$FAM <- as.character(parents$FAM)
ped <- reduce.ped(ped = ped, parents = all_candidates)
check.n_fam_crosses(n_fam_crosses)
check.max_F(max_F)
check.method(method)
# if(!is.null(all_candidates)) {
all_candidates <- check.all_candidates(ped, parents, all_candidates)
str(parents)
all_candidates$FAM <- as.character(all_candidates$FAM)
ped <- reduce.ped(ped = ped, parents = all_candidates)
check.n_fam_crosses(n_fam_crosses)
check.max_F(max_F)
check.method(method)
# if(!is.null(all_candidates)) {
all_candidates <- check.all_candidates(ped, parents, all_candidates)
#ped <- nadiv::prunePed(ped = ped, phenotyped = parents$ID)
ped[ped$DAM  == 0 & !is.na(ped$DAM), "DAM"]  <- NA
ped[ped$SIRE == 0 & !is.na(ped$SIRE),"SIRE"] <- NA
# ped <- nadiv::prepPed(ped = ped)
ped <- ped.order(pedigree = ped)
ped[is.na(ped$DAM), "DAM"]  <- 0
ped[is.na(ped$SIRE),"SIRE"] <- 0
# H <- makeA(ped)  #unstable with large pedigrees, use Amatrix instead
H <- AGHmatrix::Amatrix(ped)
H <- H[rownames(H) %in% parents$ID, colnames(H) %in% parents$ID]
H <- as.matrix(H)
tail(ped)
AGHmatrix::Amatrix(ped)
write.csv(ped,"../ped_check.csv",row.names = F)
str(ped)
ped$DAM <- as.character(ped$DAM)
ped$SIRE <- as.character(ped$SIRE)
AGHmatrix::Amatrix(ped)
source("C:/Users/MHamilton/OneDrive - CGIAR/Desktop/allocatemate/R/peripheral_functions.R")
source("C:/Users/MHamilton/OneDrive - CGIAR/Desktop/allocatemate/R/allocate.mate.ped.R")
parents<- read.csv("../parents.csv")
ped<- read.csv("../ped.csv")
parents$FAM <- as.character(parents$FAM)
source("C:/Users/MHamilton/OneDrive - CGIAR/Desktop/allocatemate/R/peripheral_functions.R")
#Feb 2021
#if("nadiv" %in% installed.packages()[, "Package"] == F) {install.packages("nadiv")}
#library(nadiv)
#library(lpSolveAPI)
#library(AGHmatrix)
#library(dplyr)
#split parents
if(!"N_AS_PARENT" %in% colnames(parents)) {
stop("Column N_AS_PARENT is not present in \'parents\'.")
}
if(!is.integer(parents$N_AS_PARENT)) {
stop("N_AS_PARENT must be a vector of type integer")
}
if(sum(is.na(parents$N_AS_PARENT)) != 0) {
stop("N_AS_PARENT contains missing values")
}
all_candidates <- parents
parents <- parents[parents$N_AS_PARENT > 0,]
#  if(nrow(parents) == nrow(all_candidates)) {
#    all_candidates <-  NULL
#  }
check.parents(parents)
check.ped2(ped)
ped <- reduce.ped(ped = ped, parents = all_candidates)
check.n_fam_crosses(n_fam_crosses)
check.max_F(max_F)
check.method(method)
# if(!is.null(all_candidates)) {
all_candidates <- check.all_candidates(ped, parents, all_candidates)
#  }
#ped <- nadiv::prunePed(ped = ped, phenotyped = parents$ID)
ped[ped$DAM  == 0 & !is.na(ped$DAM), "DAM"]  <- NA
ped[ped$SIRE == 0 & !is.na(ped$SIRE),"SIRE"] <- NA
# ped <- nadiv::prepPed(ped = ped)
ped <- ped.order(pedigree = ped)
ped[is.na(ped$DAM), "DAM"]  <- 0
ped[is.na(ped$SIRE),"SIRE"] <- 0
# H <- makeA(ped)  #unstable with large pedigrees, use Amatrix instead
H <- AGHmatrix::Amatrix(ped)
H <- H[rownames(H) %in% parents$ID, colnames(H) %in% parents$ID]
H <- as.matrix(H)
families <- generate.fams(H = H, ped = ped, parents = parents, max_F = max_F)
if(method == "assortative") {
output <- solve_lp(families = families, parents = parents, n_fam_crosses = n_fam_crosses, max_F = max_F, min_trait = "EBV_dev_squared")
}
if(method == "min_F") {
output <- solve_lp(families = families, parents = parents, n_fam_crosses = n_fam_crosses, max_F = max_F, min_trait = "F")
}
#  if(!is.null(all_candidates)) {
output$mating_list <- get_optimal_all_candidates(optimal_families = output$optimal_families,
all_candidates = all_candidates)
optimal_families = output$optimal_families
optimal_families$CROSS <- 1:nrow(optimal_families)
sires <- get.parents(all_candidates, optimal_families, sex = "M")
optimal_families
all_candidates
get.parents(all_candidates, optimal_families, sex = "M")
